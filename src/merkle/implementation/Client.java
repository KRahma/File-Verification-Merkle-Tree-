package merkle.implementation;

import merkle.Configuration;
import merkle.IClient;
import merkle.IMerkleTree;

import java.util.List;


/**
 * TASK 2
 * TODO: IMPLEMENT verifyResponse
 *
 * @author Kazi Rahma
 * @pso 12
 * @loginID krahma
 * @date October 20, 2016
 */
public class Client extends IClient {

    /**
     * Given the path siblings this function has to verify if
     * the masterHash generated by concatenating and hashing
     * level by level is the same as <i>this.masterHash</i>
     * You can use <i>Configuration.hashFunction</i>
     */
    protected boolean verifyResponse(List<IMerkleTree.Node> pathSiblings) throws Exception {
        //TODO:implement
        boolean matched = false;
        /*
         * You need to use Configuration.hashFunction and this.masterHash to determine a match
         */

        int listsize = pathSiblings.size(); //list size
        IMerkleTree.Node selected = pathSiblings.get(0); //get the very first one
        IMerkleTree.Node sibling = pathSiblings.get(1); //get the second node from the list to uild the first parent
        IMerkleTree.Node parent;
        int parentIndex = (int) Math.floor(sibling.getIndex() / 2); //getting the parent index
        int listIndex = 2; //initialize it to 2 so that's where you start from

        if(selected.getType() == IMerkleTree.NodeType.right){ //this check is only to make sure the ordering in which to pass the the hash function
            //if the selected one is right then pass it as the second argument in the hash function
            parent = new IMerkleTree.Node(Configuration.hashFunction.concatenateHash(sibling, selected), parentIndex);
        }
        else{
            parent = new IMerkleTree.Node(Configuration.hashFunction.concatenateHash(selected, sibling), parentIndex);
        }

        selected = parent; //make the selected node equal to the parent node we just found out by hashing

        while (listIndex < listsize){ //if the listINdex reaches the end it won't execute the while loop

            sibling = pathSiblings.get(listIndex); //get the sibling node from the verification list
            parentIndex = (int) Math.floor(sibling.getIndex() / 2); //calculate the parent index

            if(sibling.getType() == IMerkleTree.NodeType.right){

                //if the sibling is right then pass it as the second argument to the hash function
                parent = new IMerkleTree.Node(Configuration.hashFunction.concatenateHash(selected, sibling), parentIndex);

            }
            else{

                parent = new IMerkleTree.Node(Configuration.hashFunction.concatenateHash(sibling, selected), parentIndex);
            }

            selected = parent; //the hashed node which we get as the parent is the node which was selected in the path
            listIndex++; //increase the index by 1 so that it check the next node in the verification list
        }

        if(this.masterHash.equals(parent.getHash())){
            matched = true;
        }

        return matched;
    }
}
